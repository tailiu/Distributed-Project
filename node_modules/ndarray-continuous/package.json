{
  "name": "ndarray-continuous",
  "version": "0.4.2",
  "description": "Create continuous \"chunked\" grids/volumes with ndarrays",
  "main": "index.js",
  "scripts": {
    "test": "node test.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/hughsk/ndarray-continuous.git"
  },
  "keywords": [
    "grid",
    "volume",
    "voxel",
    "continuous",
    "infinite",
    "ndarray"
  ],
  "author": {
    "name": "Hugh Kennedy",
    "email": "hughskennedy@gmail.com",
    "url": "http://hughskennedy.com/"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "dependencies": {
    "map-async": "~0.1.1",
    "cell-range": "0.0.0",
    "zeros": "0.0.0",
    "ndarray-group": "0.0.1",
    "inherits": "~2.0.0",
    "morton-page": "~0.1.0"
  },
  "devDependencies": {
    "isndarray": "~0.1.0",
    "tape": "~1.0.4",
    "ndarray-unpack": "0.0.0",
    "ndarray-fill": "~0.1.0",
    "cave-automata-2d": "~0.3.0"
  },
  "readme": "# ndarray-continuous [![unstable](https://rawgithub.com/hughsk/stability-badges/master/dist/unstable.svg)](http://github.com/hughsk/stability-badges) #\n\nAn experiment with creating continuous grids/volumes from \"chunked\"\n[ndarrays](http://github.com/mikolalysenko/ndarray). Ideally, this could make\nit easy to work with infinite terrain, or simply splitting a large area into\nsmaller chunks to conserve memory - while still taking advantage of the modules\ndesigned to work with ndarrays.\n\nThe interface supports both asynchronous and synchronous getters, in case you\nwant to back the chunks with a local storage mechanism such as\n[level.js](http://github.com/maxogden/level.js).\n\n## API ##\n\n### `field = require('ndarray-continuous')(options)` ###\n\nTakes an options object, with the following properties:\n\n* `shape`: the shape (dimensions) of each chunk.\n* `getter`: a function that is called when a new chunk is required.\n\nThe `getter` function takes two arguments, `position` and `done`. The former\nis the chunk's position (in chunks, not units), and the latter is a Node-style\ncallback for returning the new array. If you want to retrieve chunks\nsynchronously you can return the array as well. All chunks must be the same\nshape as specified in the `shape` option.\n\n### `field.chunk(position[, done])` ###\n\nRetrieves a single chunk, by its position in chunkspace.\n\n### `field.group(hi, lo[, done])` ###\n\nRetrieves a [proxy](http://github.com/mikolalysenko/ndarray-proxy) array\ncombining the chunks between `hi` and `lo` inclusive.\n\n### `field.range(hi, lo[, done])` ###\n\nRetrieve a proxy array that represents the points (in units) between `hi` and\n`lo`. Unlike `group` and `chunk`, you can use this to select an arbitrary area\nof elements.\n\n### `field.index` ###\n\nThe local chunk cache - an object containing each chunk, indexed by their\npositions.\n\n### `field.remove(position[, done])` ###\n\nClears a chunk from the local object cache - you should be doing this when\nyou're no longer using a chunk to conserve memory.\n\n``` javascript\nvar field = require('ndarray-continuous')({\n    shape: [50, 50, 50]\n  , getter: function(position, done) {\n    return done(null, zeros([50, 50]))\n  }\n})\n\nvar array = field.group([-5, -5, -5], [5, 5, 5])\nrequire('cave-automata-2d')(array)(10)\n\n// things happen...\nsetTimeout(function() {\n  field.each(function(chunk) {\n    field.remove(chunk.position)\n  })\n}, 1000)\n```\n\n### `field.get(position[, done])` ###\n\nA shorthand method for getting individual values directly by their position on\nthe continuous ndarray.\n\n### `field.set(position, value[, done])` ###\n\nA shorthand method for setting individual values directly by their position on\nthe continuous ndarray.\n\n### `field.each(iterator)` ###\n\nCalls `iterator` for each currently instantiated chunk, passing the chunk as\nthe first argument.\n\n### `field.size()` ###\n\nReturns the amount of chunks currently instantiated.\n\n### `field.on('created', callback)` ###\n\nCalled when a fresh chunk has been loaded - passing the chunk as an argument to\nthe callback.\n\n### `field.on('removed', callback)` ###\n\nCalled when a chunk has been removed - passing the chunk as an argument to the\ncallback.\n",
  "bugs": {
    "url": "https://github.com/hughsk/ndarray-continuous/issues"
  },
  "_id": "ndarray-continuous@0.4.2",
  "dist": {
    "shasum": "2ab133d568c6768c110cb42f74fae25e3610953d",
    "tarball": "http://registry.npmjs.org/ndarray-continuous/-/ndarray-continuous-0.4.2.tgz"
  },
  "_from": "ndarray-continuous@*",
  "_npmVersion": "1.3.11",
  "_npmUser": {
    "name": "hughsk",
    "email": "hughskennedy@gmail.com"
  },
  "maintainers": [
    {
      "name": "hughsk",
      "email": "hughskennedy@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "2ab133d568c6768c110cb42f74fae25e3610953d",
  "_resolved": "https://registry.npmjs.org/ndarray-continuous/-/ndarray-continuous-0.4.2.tgz"
}
