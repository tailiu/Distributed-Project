// Generated by CoffeeScript 1.12.7
(function() {
  var Client, Session, net, tls,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  net = require("net");

  tls = require("tls");

  Session = require("./tcp_session");

  Client = (function(superClass) {
    var connected, connecting, lastID, requests;

    extend(Client, superClass);

    requests = {};

    lastID = 0;

    connected = false;

    connecting = false;

    function Client(port, host, secure) {
      Client.__super__.constructor.call(this);
      this.on("error", function() {
        return connected = false;
      });
      this.timeout = 60000;
      if ((host != null) && (port != null)) {
        this.connect(port, host, secure);
      }
      this.on("message", (function(_this) {
        return function(message) {
          var request;
          if (message.id == null) {
            return _this.emit(message.method, message.result);
          } else {
            request = requests[message.id];
            if (request != null) {
              request.replies++;
              request.time = Date.now();
              if (message.error != null) {
                request.callback(message.error, message.result);
                return _this.cancelRequest(request.id);
              } else {
                return request.callback(null, message.result);
              }
            }
          }
        };
      })(this));
      setInterval((function(_this) {
        return function() {
          var _, now, request, results;
          now = Date.now();
          results = [];
          for (_ in requests) {
            request = requests[_];
            if ((now - request.time) > request.timeout) {
              if (!request.replies) {
                request.callback("timeout");
              }
              results.push(_this.cancelRequest(request.id));
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
      })(this), this.timeout);
    }

    Client.prototype.connect = function(port1, host1, secure1, callback) {
      var transport;
      this.port = port1;
      this.host = host1;
      this.secure = secure1;
      connecting = true;
      transport = this.secure != null ? tls : net;
      this.init(transport.connect(this.port, this.host, (function(_this) {
        return function(err) {
          connecting = false;
          _this.emit("connect-result", err);
          return typeof callback === "function" ? callback(err) : void 0;
        };
      })(this)));
      this.socket.on("connect", (function(_this) {
        return function() {
          if (!connected) {
            connected = true;
            return _this.emit("connect");
          }
        };
      })(this));
      return this.socket.on("close", function() {
        return connected = false;
      });
    };

    Client.prototype.reconnect = function(callback) {
      this.socket.destroy();
      return this.connect(this.port, this.host, this.secure, callback);
    };

    Client.prototype.onceReady = function(callback) {
      if (connected) {
        return callback();
      } else {
        return this.once("connect", callback);
      }
    };

    Client.prototype.onceConnected = function(callback) {
      if (connected) {
        return callback();
      } else {
        return this.once("connect-result", callback);
      }
    };

    Client.prototype.cancelRequest = function(id) {
      return delete requests[id];
    };

    Client.prototype.call = function(method, params, callback, timeout) {
      if (connected) {
        return this._call(method, params, callback, timeout);
      } else {
        if (connecting) {
          return this.onceConnected((function(_this) {
            return function(err) {
              if (err != null) {
                return callback(err);
              } else {
                return _this._call(method, params, callback, timeout);
              }
            };
          })(this));
        } else {
          return this.reconnect((function(_this) {
            return function(err) {
              if (err != null) {
                return callback(err);
              } else {
                return _this._call(method, params, callback, timeout);
              }
            };
          })(this));
        }
      }
    };

    Client.prototype._call = function(method, params, callback, timeout) {
      var id;
      id = ++lastID;
      return this.sendMessage(id, method, params, (function(_this) {
        return function(err) {
          if (err) {
            return callback(err);
          } else {
            return requests[id] = {
              id: id,
              time: (new Date).getTime(),
              callback: callback,
              replies: 0,
              timeout: timeout || _this.timeout
            };
          }
        };
      })(this));
    };

    return Client;

  })(Session);

  module.exports = Client;

}).call(this);
